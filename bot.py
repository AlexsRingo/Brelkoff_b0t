\
import os
import json
import logging
import asyncio
from datetime import datetime
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiohttp import web

# ========= CONFIG =========
API_TOKEN = os.getenv("API_TOKEN")
ADMINS = list(map(int, os.getenv("ADMINS", "").split(","))) if os.getenv("ADMINS") else []
SUPPORT_CONTACT = os.getenv("SUPPORT_CONTACT", "@Dashq0")
WELCOME_PIC = os.getenv("WELCOME_PIC", "https://placekitten.com/600/350")
BINGO_PIC = os.getenv("BINGO_PIC", "https://placekitten.com/600/400")
NEWS_CHANNEL_ID = os.getenv("NEWS_CHANNEL_ID", "-1002900328490")
NEWS_CHANNEL_LINK = os.getenv("NEWS_CHANNEL_LINK", "https://t.me/+EVFwvTKKwlJhOTNi")

WORDS_MAP = {
    "—É—à–∞—Å—Ç–∏–∫": {"type": "id", "value": -1002900328490},
    "–≥–µ–Ω–Ω–∞–¥–∏–π": {"type": "link", "value": "https://t.me/+E8VHovI3OAcyYjQy"},
}

USERS_FILE = "users.json"
BINGO_FILE = "bingo.json"

logging.basicConfig(level=logging.INFO)
bot = Bot(token=API_TOKEN)
dp = Dispatcher()

# ========= HELPERS =========
def load_json(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return {}

def save_json(path, data):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logging.error(f"Error saving {path}: {e}")

def load_list(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return []

def save_list(path, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def add_user(user_id):
    users = load_list(USERS_FILE)
    if user_id not in users:
        users.append(user_id)
        save_list(USERS_FILE, users)

def _normalize_chat_ref(v: str):
    v = (v or "").strip()
    if v.startswith("-100"):
        return int(v)
    if v.startswith("@"):
        return v
    return f"@{v}" if v else v

# ========= KEYBOARDS =========
def reply_kb():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="–°–¢–ê–†–¢"), KeyboardButton(text="–ë–ò–ù–ì–û")]],
        resize_keyboard=True
    )

def bingo_kb():
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ì–û–¢–û–í–û", callback_data="bingo_done")
    kb.adjust(1)
    return kb.as_markup()

# ========= WEB KEEP-ALIVE =========
async def handle(request):
    return web.Response(text="Bot is alive")

async def start_web_app():
    app = web.Application()
    app.router.add_get("/", handle)
    port = int(os.getenv("PORT", 5000))
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", port)
    await site.start()

# ========= COMMANDS =========
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    add_user(message.from_user.id)
    text = (
        "–ü—Ä–∏–≤–µ—Ç!\\n"
        "–ù–∞ —Å–≤—è–∑–∏ –î–∞—à–∞ ‚Äî –æ—Å–Ω–æ–≤–∞—Ç–µ–ª—å –±—Ä–µ–Ω–¥–∞ BRELKOF.\\n"
        "–°–ø–∞—Å–∏–±–æ, —á—Ç–æ —Ç—ã —Å –Ω–∞–º–∏! üíõ\\n\\n"
        "–ß—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º, –≤–≤–µ–¥–∏ –∫–æ–¥–æ–≤–æ–µ —Å–ª–æ–≤–æ —Å –ª–∏—Å—Ç–æ–≤–∫–∏ —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /slovo\\n\\n"
        f"–ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –≤–æ–ø—Ä–æ—Å—ã ‚Äî –ø–∏—à–∏ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É: {SUPPORT_CONTACT}"
    )
    try:
        await message.answer_photo(WELCOME_PIC, caption=text, reply_markup=reply_kb())
    except:
        await message.answer(text, reply_markup=reply_kb())

@dp.message(Command("info"))
async def cmd_info(message: types.Message):
    text = (
        "‚ÑπÔ∏è –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞:\\n"
        "/start ‚Äî –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ\\n"
        "/slovo ‚Äî –≤–≤–µ—Å—Ç–∏ –∫–æ–¥–æ–≤–æ–µ —Å–ª–æ–≤–æ\\n"
        "/getid ‚Äî ID —á–∞—Ç–∞\\n"
        "/info ‚Äî –ø–æ–º–æ—â—å\\n"
        "/broadcast ‚Äî (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤) —Ä–∞—Å—Å—ã–ª–∫–∞ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"
    )
    await message.answer(text, reply_markup=reply_kb())

@dp.message(Command("getid"))
async def cmd_getid(message: types.Message):
    await message.answer(f"ID —ç—Ç–æ–≥–æ —á–∞—Ç–∞: {message.chat.id}")

@dp.message(Command("slovo"))
async def cmd_slovo(message: types.Message):
    await message.answer("‚úèÔ∏è –í–≤–µ–¥–∏ –∫–æ–¥–æ–≤–æ–µ —Å–ª–æ–≤–æ:")

# ========= CODE WORDS =========
async def deliver_access(message: types.Message, word: str):
    data = WORDS_MAP.get(word.lower())
    if not data:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω–æ–µ —Å–ª–æ–≤–æ. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.", reply_markup=reply_kb())
        return
    if data["type"] == "id":
        try:
            invite = await bot.create_chat_invite_link(chat_id=data["value"], member_limit=1)
            await message.answer("üéâ –û—Ç–ª–∏—á–Ω–æ! –î–µ—Ä–∂–∏ –¥–æ—Å—Ç—É–ø:\\n" + invite.invite_link, reply_markup=reply_kb())
        except Exception as e:
            await message.answer(f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {e}")
    elif data["type"] == "link":
        await message.answer("üéâ –û—Ç–ª–∏—á–Ω–æ! –î–µ—Ä–∂–∏ –¥–æ—Å—Ç—É–ø:\\n" + data["value"], reply_markup=reply_kb())

# ========= BROADCAST =========
@dp.message(Command("broadcast"))
async def cmd_broadcast(message: types.Message):
    if message.from_user.id not in ADMINS:
        return await message.answer("‚õî –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤.")
    parts = message.text.split(maxsplit=1)
    if len(parts) < 2:
        return await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /broadcast <—Ç–µ–∫—Å—Ç>")
    text = parts[1]
    users = load_list(USERS_FILE)
    sent = 0
    for uid in users:
        try:
            await bot.send_message(uid, text)
            sent += 1
        except:
            pass
    await message.answer(f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ {sent} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.")

# ========= BINGO =========
@dp.message(F.text == "–ë–ò–ù–ì–û")
async def btn_bingo(message: types.Message):
    try:
        chat_for_check = _normalize_chat_ref(NEWS_CHANNEL_ID)
        member = await bot.get_chat_member(chat_for_check, message.from_user.id)
        if getattr(member, "status", None) not in ("member", "administrator", "creator"):
            return await message.answer("‚ùå –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª!", reply_markup=reply_kb())
    except Exception as e:
        return await message.answer(
            f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏.\\n"
            f"–ü—Ä–æ–≤–µ—Ä—è–ª: {NEWS_CHANNEL_ID}\\n"
            f"–î–µ—Ç–∞–ª–∏: {e}"
        )

    text = (
        "–ê –µ—â–µ —É –Ω–∞—Å –µ—Å—Ç—å –ë–ò–ù–ì–û üòç\\n\\n"
        "–í—ã–ø–æ–ª–Ω–∏ –∑–∞–¥–∞–Ω–∏—è –∏ –ø–æ–ª—É—á–∏ –ø—Ä–æ–º–æ–∫–æ–¥ 15% —Å–µ–±–µ –∏–ª–∏ –¥—Ä—É–≥—É\\n"
        "ü•∞ –ø—Ä–æ–º–æ–∫–æ–¥ –µ–¥–∏–Ω–æ—Ä–∞–∑–æ–≤—ã–π\\n\\n"
        "1. –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –¢–µ–ª–µ–≥—Ä–∞–º –∏ –ò–Ω—Å—Ç–∞–≥—Ä–∞–º\\n"
        "2. –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤ –Ω–∞ –û–∑–æ–Ω–µ –∏–ª–∏ –í–ë / –µ—Å–ª–∏ –Ω–∞–±–æ—Ä –ø–æ–¥–∞—Ä–∏–ª–∏ ‚Äî –≤ –ø–æ—Å—Ç–µ\\n"
        "3. –í—ã–ª–æ–∂–∏—Ç—å –∑–∞–π—Ü–∞ –≤ —Å–æ—Ü.—Å–µ—Ç–∏, –æ—Ç–º–µ—Ç–∏–≤ BRELKOF\\n"
        "4. –î–∞—Ç—å –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å –ø–æ –∫–Ω–æ–ø–∫–µ –Ω–∏–∂–µ\\n\\n"
        "ü•∞ –ü–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç—ã–∫–∞–π –ì–û–¢–û–í–û"
    )
    try:
        await message.answer_photo(BINGO_PIC, caption=text, reply_markup=bingo_kb())
    except:
        await message.answer(text, reply_markup=bingo_kb())

@dp.callback_query(F.data == "bingo_done")
async def bingo_done(callback: types.CallbackQuery):
    uid = str(callback.from_user.id)
    bingo_data = load_json(BINGO_FILE)
    user_data = bingo_data.get(uid, {})
    if not user_data.get("review") or not user_data.get("social"):
        await callback.message.answer("‚ùå –¢—ã –Ω–µ –ø—Ä–∏—Å–ª–∞–ª –≤—Å–µ —Å—Å—ã–ª–∫–∏. –ù—É–∂–Ω–æ –æ—Ç–∑—ã–≤ –∏ –ø–æ—Å—Ç –≤ —Å–æ—Ü—Å–µ—Ç—è—Ö.")
    else:
        for admin in ADMINS:
            try:
                await bot.send_message(
                    admin,
                    f"üì© –ó–∞—è–≤–∫–∞ –ë–ò–ù–ì–û –æ—Ç @{callback.from_user.username or callback.from_user.id}\\n"
                    f"–û—Ç–∑—ã–≤: {user_data['review']}\\n–°–æ—Ü—Å–µ—Ç–∏: {user_data['social']}"
                )
            except:
                pass
        await callback.message.answer("‚úÖ –°–ø–∞—Å–∏–±–æ! –ú—ã –ø—Ä–æ–≤–µ—Ä–∏–º –∑–∞–¥–∞–Ω–∏—è –∏ –≤—Ä—É—á–Ω—É—é –æ—Ç–ø—Ä–∞–≤–∏–º –ø—Ä–æ–º–æ–∫–æ–¥ ü•∞")
    try:
        await callback.answer()
    except:
        pass

# ========= LINKS HANDLER =========
@dp.message(F.text.regexp(r'^https?://'))
async def handle_links(message: types.Message):
    uid = str(message.from_user.id)
    bingo_data = load_json(BINGO_FILE)
    if uid not in bingo_data:
        bingo_data[uid] = {"username": message.from_user.username}
    if not bingo_data[uid].get("review"):
        bingo_data[uid]["review"] = message.text.strip()
        await message.answer("‚úÖ –°—Å—ã–ª–∫–∞ –Ω–∞ –æ—Ç–∑—ã–≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! –¢–µ–ø–µ—Ä—å –ø—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ—Å—Ç –≤ —Å–æ—Ü—Å–µ—Ç—è—Ö üê∞")
    elif not bingo_data[uid].get("social"):
        bingo_data[uid]["social"] = message.text.strip()
        await message.answer("‚úÖ –°—Å—ã–ª–∫–∞ –Ω–∞ —Å–æ—Ü—Å–µ—Ç–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! –¢–µ–ø–µ—Ä—å –∂–º–∏ –ì–û–¢–û–í–û üòç")
    else:
        await message.answer("‚ö†Ô∏è –¢—ã —É–∂–µ –ø—Ä–∏—Å–ª–∞–ª –≤—Å–µ —Å—Å—ã–ª–∫–∏. –ñ–º–∏ –ì–û–¢–û–í–û!")
    save_json(BINGO_FILE, bingo_data)

# ========= GENERAL MESSAGES =========
@dp.message()
async def all_messages(message: types.Message):
    text = (message.text or "").strip().lower()
    if text in WORDS_MAP:
        return await deliver_access(message, text)
    add_user(message.from_user.id)

# ========= RUN =========
async def main():
    asyncio.create_task(start_web_app())
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
